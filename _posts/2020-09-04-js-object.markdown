---
layout: post  
title: "JS面向对象 - 全都是'泡沫'?"  
date: 2020-09-04  
categories: javascript  
tags: js  
---

## JS中的面向对象  
来个问题先  
![函数对象和对象]({{ site.url }}/land/pics/object-1.png)  
然后如何把 prototype, \__proto__, constructor 三个属性对应上  

- #### prototype  
  每个函数都有一个prototype属性。*prototype是函数才会有的属性*  
  这个函数的prototype属性指向该对象的原型  

- #### \__proto__  
  每一个JavaScript对象(除了null)都具有的一个属性, 叫__proto__, 这个属性会指向该对象的原型。  
  *当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)*  
  **埋个伏笔: Function对象.__proto__呢，这个主要用于做什么的**

- #### constructor  
  原型对象指向构造函数  

![原型链]({{ site.url }}/land/pics/object-2.png)  

``` javascript  
  function Person() {}
  var person = new Person();
  console.log(person.__proto__ === Person.prototype);
```  

没有 Object.create、Object.setPrototypeOf 的早期版本中，**new运算是唯一一个可以指定[[prototype]]的方法**。  

### 原型的原型  
![原型的原型]({{ site.url }}/land/pics/object-3.png)  

### JS实现面向对象的方式选择的是原型系统  
- JS通过原型的方式来描述对象  
- 使用原型和原型链来实现继承，很多同学说继承不合适，可以理解成委托  

### JS对象的属性  
- 第一类属性: 数据属性。  
  - value: 属性的值, 默认值为undefined  
  - writable: 属性能否被赋值  
  - enumerable: 能否枚举  
  - configurable: 属性能否被删除或者改变特征值  

- 第二类属性: 访问器（getter/setter）属性。  
  - getter: 函数或 undefined，在取属性值时被调用  
  - setter: 函数或 undefined，在设置属性值时被调用  
  - enumerable: 能否枚举  
  - configurable: 属性能否被删除或者改变特征值  

## V8里对象的属性  
- 常规属性(properties)  
- 排序属性 (element)  
- \__proto__ 属性  
- 隐藏类(map)  

常规属性和排序属性理解为V8为了提升查找效率  
可以理解为属性少的时候查找效率高，属性多查找效率低  
\__proto__ 属性为了方便我们访问[[property]]访问器属性  
隐藏类(map)是浏览器为了高效的解析对象  

### 隐藏类(map)  
它主要包括了属性名称和每个属性所对应的偏移量  
V8拿对象的起始位置加上偏移量，就得到属性的值在内存中的位置  
**有了这个隐藏类，V8在解析的时候可以提高速度**  
#### 多个对象共用一个隐藏类  
*两个对象的形状是相同的，V8 就会为其复用同一个隐藏类*  
两个对象的形状是相同的，要满足以下两点  
- 相同的属性名称  
- 相等的属性个数  

现在我们构造对象的时候基本使用class，初始化的时候顺序和个数基本都是一样的，但是有些对对象的操作也会**重新构建隐藏类**，所以我们在开发的时候可以尽量避免  
可以用d8工具来看看哪些操作会重新构建隐藏类  
首先我们来创建一个类，并且用它来实例化一些对象，然后用d8观察一下它  
``` javascript  
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const person1 = new Person('person1', 20);
const person2 = new Person('person2', 22);
const person3 = new Person('person3', 23);
%DebugPrint(person1);
%DebugPrint(person2);
%DebugPrint(person3);
```  

然后我们通过d8观察一下对象，其中map隐藏类的地址都为一样的:  
![map隐藏类]({{ site.url }}/land/pics/object-4.png)  
- 试试修改属性  
  ``` javascript  
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }

  const person1 = new Person('person1', 20);
  const person2 = new Person('person2', 22);
  const person3 = new Person('person3', 23);
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);

  person1.age = 30;
  person2.age = 31;
  person3.age = 29;
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);
  ```  
  ![修改对象属性]({{ site.url }}/land/pics/object-5.png)  
  map隐藏类的地址都为一样的  
- 添加属性  
  ``` javascript  
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }

  const person1 = new Person('person1', 20);
  const person2 = new Person('person2', 22);
  const person3 = new Person('person3', 23);
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);

  person1.job = '';
  person2.car = '';
  person3.bag = '';
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);
  ```  
  ![添加属性]({{ site.url }}/land/pics/object-6.png)  
  添加新的属性都会重新构建隐藏类  
- 删除属性  
  ``` javascript  
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  }

  const person1 = new Person('person1', 20);
  const person2 = new Person('person2', 22);
  const person3 = new Person('person3', 23);
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);

  delete person1.name;
  delete person2.age;
  %DebugPrint(person1);
  %DebugPrint(person2);
  %DebugPrint(person3);
  ```  
  ![删除属性]({{ site.url }}/land/pics/object-7.jpeg)  
  删除属性也会重新构建隐藏类  

**所以我们在开发的时候尽量避免使用delete，初始化的时候也尽量一次性完整且顺序的初始化对象。**  

## 最后看看babel是如何编译的  
### bable编译的class对象  
这里挑主要的babel编译代码:  
``` javascript  
var Person = /*#__PURE__*/function () {
  function Person(name) {
    _classCallCheck(this, Person);
    this.name = name;
  }

  _createClass(Person, [{
    key: "sayName",
    value: function sayName() {
      console.log(this.name);
    }
  }]);

  return Person;
}();
```  
关注的点:  
- _classCallCheck
  防止不是new的方式调用这个构造函数  
  ``` javascript  
  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { 
      return !!right[Symbol.hasInstance](left);
    } else { 
      return left instanceof right;
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!_instanceof(instance, Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  ```  
- 通过_createClass挂方法  
  - 动态方法挂到Constructor.prototype上  
  - 静态方法直接挂到Constructor上  
  ``` javascript  
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  ```  

### bable编译的extend  
继承我们主要看_inherits  
``` javascript  
function _inherits(subClass, superClass) { 
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function"); 
  } 
  subClass.prototype = Object.create(
    superClass && superClass.prototype, 
    { constructor: { value: subClass, writable: true, configurable: true } }
  ); 
  if (superClass) _setPrototypeOf(subClass, superClass);
}
```  
- Object.create  
  ``` javascript  
  function _inherits(subClass, superClass) { 
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function"); 
    } 
    subClass.prototype = Object.create(
      superClass && superClass.prototype, 
      { constructor: { value: subClass, writable: true, configurable: true } }
    ); 
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  ```  
- _setPrototypeOf: Function.__proto__  
  ``` javascript  
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { 
      o.__proto__ = p; 
      return o;
    }; 
    return _setPrototypeOf(o, p); 
  }
  ```  
  **伏笔在这,继承父类的静态属性**  

### 私有属性  
下一代规范使用\#xxx表示xxx是个私有属性  
一般是两种实现方式  
- 常规的用Symbol做key加闭包的方式  
  ``` javascript  
  (function() {
    var key = Symbol('private'); // 外部拿不到这个key
    function Person() {
      this[key] = 10;
    }

    buy() {
      this[key] -= 10;
    }
  })()
  ```  
- babel编译的: 使用WeakMap 通过实例的this做关联  
  ``` javascript  
  (function() {
    var privateProperites = new WeakMap() // 以实例为key 里面的key不算引用计数
    // Map
    function Person() {
      privateProperites.set(this, {
        money: 10
      })
    }

    getMoney() {
      privateProperites.get(this)['money']
    }
  })()
  ```  
  **使用WeakMap是为了垃圾回收(里面的key不算引用计数)**